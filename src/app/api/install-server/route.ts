import { NextResponse } from 'next/server';
import path from 'path';
import fs from 'fs/promises'; // Use promises for async file operations
import { execa } from 'execa'; // Use execa for running commands
import { MARKET_SERVERS, MarketServerDefinition } from '@/lib/market-servers'; // Import definitions
import { v4 as uuidv4 } from 'uuid';

// Define the expected response structure (matching frontend ServerConfig)
interface ServerConfig {
  id: string;
  name: string;
  path: string; // Path to the executable (script, wrapper, etc.)
  env: string;
  marketId?: string;
}

// Base directory for installing servers within the project
const SERVERS_INSTALL_DIR = path.resolve(process.cwd(), 'mcp-servers');

// --- Re-introduced Helper to run commands ---
async function runCommands(commands: string[], cwd: string, env: Record<string, string>) {
    for (const command of commands) {
        console.log(`[Installer API] Running command in ${cwd}: ${command}`);
        const [executable, ...args] = command.split(' '); // Basic split
        try {
            const { stdout, stderr } = await execa(executable, args, { 
                cwd, 
                env: { ...process.env, ...env }, // Merge process env with definition env
                stdio: 'pipe' // Capture output
            });
            console.log(`[Installer API] > ${command} stdout:\n${stdout}`);
            if (stderr) {
                console.warn(`[Installer API] > ${command} stderr:\n${stderr}`);
            }
        } catch (error: any) {
            console.error(`[Installer API] Error running command: ${command}`, error);
            throw new Error(`Command failed: ${command}. Error: ${error.stderr || error.stdout || error.message}`);
        }
    }
}

// Helper function to generate the runner script content
function generateRunnerScript(npxCommand: string, envJsonString: string): string {
    // Basic script for POSIX environments (Linux/macOS)
    // In a real-world scenario, might need platform detection (e.g., for Windows)
    // Using process.env directly might be problematic if the script is run by a different user/context later.
    // It's safer to explicitly export vars derived from envJsonString.

    // Parse the env string to set variables explicitly
    let envExports = '';
    try {
        const envVars = JSON.parse(envJsonString);
        for (const key in envVars) {
            // Simple escaping for basic cases, might need more robust handling
            const value = String(envVars[key]).replace(/'/g, "'\\''"); 
            envExports += `export ${key}='${value}'\n`;
        }
    } catch (e) { console.warn("[Installer API] Failed to parse env JSON for runner script", e); }

    return `#!/bin/sh
# Wrapper script generated by MCP Client Installer

# Set environment variables
${envExports}

# Execute the npx command (ensure $PORT is passed if present)
echo "[MCP Server Runner] Starting server with npx..."
${npxCommand}
`;
}

export async function POST(request: Request) {
    try {
        await fs.mkdir(SERVERS_INSTALL_DIR, { recursive: true }); // Ensure base directory exists

        const body = await request.json();
        const serverId = body.id as string;
        const envStringOverride = body.envString as string | undefined; // Accept optional env override

        if (!serverId) {
            return NextResponse.json({ error: 'Server ID is required' }, { status: 400 });
        }

        // Find the server definition (SECURITY: Only install known servers)
        const serverDef = MARKET_SERVERS.find(s => s.id === serverId);
        if (!serverDef) {
            return NextResponse.json({ error: 'Unknown or invalid server ID' }, { status: 404 });
        }

        // --- Installation Process ---
        const installDirName = serverDef.id; // Use unique ID for the directory
        const installDirPath = path.join(SERVERS_INSTALL_DIR, installDirName);
        let finalScriptPath = ''; // Path to the actual executable/wrapper
        
        // Determine environment string to use
        const finalEnvString = envStringOverride !== undefined ? envStringOverride : (serverDef.defaultEnv || '{}');
        let parsedEnv: Record<string, string> = {};
        try { parsedEnv = JSON.parse(finalEnvString); } catch { /* ignore parse error here, handle downstream */ }

        console.log(`[Installer API] Installing ${serverDef.name} (Type: ${serverDef.type}) into ${installDirPath}`);

        if (serverDef.type === 'git') {
            // --- Git Installation (with build steps) ---
            if (!serverDef.gitUrl || !serverDef.scriptPath) {
                throw new Error(`Git server definition for ${serverDef.id} is missing gitUrl or scriptPath.`);
            }
            
            // 1. Clone or verify existing repo
            try {
                await fs.access(installDirPath);
                console.log(`[Installer API] Directory ${installDirPath} already exists. Skipping clone.`);
                // TODO: Optional: Implement git pull for updates
            } catch {
                console.log(`[Installer API] Cloning ${serverDef.gitUrl} into ${installDirName}...`);
                try {
                    await execa('git', ['clone', '--depth', '1', serverDef.gitUrl, installDirName], { cwd: SERVERS_INSTALL_DIR });
                    console.log(`[Installer API] Git clone successful.`);
                } catch (error: any) {
                    console.error(`[Installer API] Git clone failed:`, error);
                    throw new Error(`Failed to clone repository: ${error.stderr || error.stdout || error.message}`);
                }
            }

            // 2. Determine working directory for commands
            const commandCwd = serverDef.subDirectory ? path.join(installDirPath, serverDef.subDirectory) : installDirPath;
            // Ensure CWD exists if it's a subdirectory
            if(serverDef.subDirectory) { await fs.access(commandCwd); }

            // 3. Run Install Commands (if any)
            if (serverDef.installCommands && serverDef.installCommands.length > 0) {
                console.log("[Installer API] Running install commands...");
                await runCommands(serverDef.installCommands, commandCwd, parsedEnv);
                console.log("[Installer API] Install commands finished.");
            }

            // 4. Run Build Commands (if any)
            if (serverDef.buildCommands && serverDef.buildCommands.length > 0) {
                console.log("[Installer API] Running build commands...");
                await runCommands(serverDef.buildCommands, commandCwd, parsedEnv);
                console.log("[Installer API] Build commands finished.");
            }

            // 5. Determine Final Script Path (relative to CWD)
            finalScriptPath = path.resolve(commandCwd, serverDef.scriptPath);

        } else if (serverDef.type === 'npx') {
            // --- NPX Installation (Wrapper Script Generation) --- 
            if (!serverDef.npxCommand) {
                throw new Error(`Server definition for ${serverDef.id} is missing npxCommand.`);
            }
            
            // Ensure the specific install directory exists
            await fs.mkdir(installDirPath, { recursive: true });

            const scriptContent = generateRunnerScript(serverDef.npxCommand, finalEnvString);
            const wrapperScriptName = 'run.sh'; // Consistent wrapper name
            finalScriptPath = path.join(installDirPath, wrapperScriptName);

            console.log(`[Installer API] Generating wrapper script at ${finalScriptPath}`);
            await fs.writeFile(finalScriptPath, scriptContent, 'utf8');
            
            // Make the script executable (important!)
            try {
                await fs.chmod(finalScriptPath, 0o755); // rwxr-xr-x
                console.log(`[Installer API] Made wrapper script executable.`);
            } catch (err: any) {
                console.error(`[Installer API] Failed to set executable permissions on ${finalScriptPath}:`, err);
                // Decide if this is fatal; maybe depends on OS/environment
                 throw new Error(`Failed to make runner script executable. Check permissions.`);
            }

        } else {
            // Should not happen with TS types, but good for JS guard
             const exhaustiveCheck: never = serverDef.type;
             throw new Error(`Unsupported server type: ${exhaustiveCheck}`);
        }

        // --- Verification & Config Creation --- 
        
        // Verify the final script/executable exists (for both git and npx)
         try {
             await fs.access(finalScriptPath);
             console.log(`[Installer API] Verified final script/executable exists at: ${finalScriptPath}`);
         } catch {
             console.error(`[Installer API] Final executable/script not found after installation at: ${finalScriptPath}`);
             throw new Error(`Installation failed: the final script/executable (${finalScriptPath}) was not found or is not accessible.`);
         }

        const installedServerConfig: ServerConfig = {
            id: uuidv4(), 
            name: serverDef.name, 
            path: finalScriptPath, // Use the determined final path
            env: finalEnvString, 
            marketId: serverDef.id 
        };

        console.log(`[Installer API] Installation successful for ${serverDef.name}. Config:`, { ...installedServerConfig, env: '[omitted]' }); // Omit env from log
        return NextResponse.json(installedServerConfig);

    } catch (error: any) {
        console.error('[Installer API] Error:', error);
        return NextResponse.json({ error: error.message || 'Installation failed' }, { status: 500 });
    }
} 